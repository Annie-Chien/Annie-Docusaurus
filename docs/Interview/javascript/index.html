<!doctype html>
<html lang="zh-Hant-TW" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-Interview/javascript">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.0">
<title data-rh="true">JavaScript 問答集 | AnnieAnny</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://annie-chien.github.io/Annie-Docusaurus/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://annie-chien.github.io/Annie-Docusaurus/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://annie-chien.github.io/Annie-Docusaurus/docs/Interview/javascript"><meta data-rh="true" name="docusaurus_locale" content="zh-Hant-TW"><meta data-rh="true" name="docsearch:language" content="zh-Hant-TW"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="JavaScript 問答集 | AnnieAnny"><meta data-rh="true" name="description" content="此篇文章主要用來整理與複習常見的 JS 面試問答，因此回答會較精簡，之後再慢慢補上針對特定主題詳細版文章。"><meta data-rh="true" property="og:description" content="此篇文章主要用來整理與複習常見的 JS 面試問答，因此回答會較精簡，之後再慢慢補上針對特定主題詳細版文章。"><link data-rh="true" rel="icon" href="/Annie-Docusaurus/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://annie-chien.github.io/Annie-Docusaurus/docs/Interview/javascript"><link data-rh="true" rel="alternate" href="https://annie-chien.github.io/Annie-Docusaurus/en/docs/Interview/javascript" hreflang="en"><link data-rh="true" rel="alternate" href="https://annie-chien.github.io/Annie-Docusaurus/docs/Interview/javascript" hreflang="zh-Hant-TW"><link data-rh="true" rel="alternate" href="https://annie-chien.github.io/Annie-Docusaurus/docs/Interview/javascript" hreflang="x-default"><link rel="stylesheet" href="/Annie-Docusaurus/assets/css/styles.e6a68978.css">
<link rel="preload" href="/Annie-Docusaurus/assets/js/runtime~main.989b89fa.js" as="script">
<link rel="preload" href="/Annie-Docusaurus/assets/js/main.83db0474.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(e){}return e}()||function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):window.matchMedia("(prefers-color-scheme: light)").matches?e("light"):e("dark")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳至主要内容"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">跳至主要内容</a></div><nav aria-label="主導航" class="navbar navbar--fixed-top navbarHideable_m1mJ"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/Annie-Docusaurus/"><b class="navbar__title text--truncate">AnnieAnny&#x27;s</b></a></div><div class="navbar__items navbar__items--right"><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/Annie-Docusaurus/docs/intro">Note</a><a href="https://github.com/Annie-Chien" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Github<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="回到頂部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd sidebarWithHideableNavbar_wUlq"><a tabindex="-1" class="sidebarLogo_isFc" href="/Annie-Docusaurus/"><b>AnnieAnny&#x27;s</b></a><nav aria-label="文件側邊欄" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/Annie-Docusaurus/docs/intro">Hello Docusaurus!</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/Annie-Docusaurus/docs/Interview/javascript">Interview</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/Annie-Docusaurus/docs/Interview/javascript">JavaScript 問答集</a></li></ul></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="頁面路徑"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主頁面" class="breadcrumbs__link" href="/Annie-Docusaurus/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Interview</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">JavaScript 問答集</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本頁導覽</button></div><div class="theme-doc-markdown markdown"><h1>JavaScript 問答集</h1><p>此篇文章主要用來整理與複習常見的 JS 面試問答，因此回答會較精簡，之後再慢慢補上針對特定主題詳細版文章。</p><div class="theme-admonition theme-admonition-note alert alert--secondary admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span><mdxadmonitiontitle>[目錄]</mdxadmonitiontitle></div><div class="admonitionContent_S0QG"><ul class="contains-task-list containsTaskList_mC6p"><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <a href="#q1">解釋 Event Bubbling</a></li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <a href="#q2">解釋 Event Delegation</a></li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <a href="#q3">什麼是 callback function</a></li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <a href="#q4">淺拷貝 vs. 深拷貝</a></li><li class="task-list-item"><input type="checkbox" disabled=""> <a href="#q5">e.currentTarget vs. e.target</a></li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <a href="#q6">什麼是 event loop?</a></li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <a href="#q7">什麼是 closure（閉包）</a></li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <a href="#q8">函式宣告式 vs. 函式運算式</a></li><li class="task-list-item"><input type="checkbox" disabled=""> <a href="#q9">什麼是 Prototype Chain</a></li></ul></div></div><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="q1">解釋 Event Bubbling<a href="#q1" class="hash-link" aria-label="解釋 Event Bubbling的直接連結" title="解釋 Event Bubbling的直接連結">​</a></h2><p>event propagation（事件傳遞）分為三個階段：</p><ol><li>event capturing 捕獲</li><li>event target：找到觸發事件</li><li>event bubbling 冒泡</li></ol><p>冒泡和捕獲最大的差別就在事件傳遞的「順序」。
冒泡的順序是從觸發事件的節點為起點，向上傳遞。而捕獲則是從根節點開始，向下傳遞直到觸發事件的節點。</p><p>addEventListener 其實有第三個參數，用來決定要採用的是冒泡或是捕獲，預設是 false 也就是冒泡。</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="q2">解釋 Event Delegation<a href="#q2" class="hash-link" aria-label="解釋 Event Delegation的直接連結" title="解釋 Event Delegation的直接連結">​</a></h2><p>使用事件冒泡（或是捕獲）的特性的一種事件處理模式。假如現在有一個 ul，裡面包了數個 li，而我們在點擊 li 的時候都想要執行某任務。那麼與其在每一個 li 身上綁定 event handler，更有效率的做法就是直接在他們的共同父層 ul 綁定 event handler。</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="q3">什麼是 callback function<a href="#q3" class="hash-link" aria-label="什麼是 callback function的直接連結" title="什麼是 callback function的直接連結">​</a></h2><div class="language-=js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-=js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">function print(callback) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    callback();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="複製代碼至剪貼簿" title="複製" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>像是以上範例，把一個函式當作參數傳入另一函式裡，並在裡面呼叫它。這個被當作參數傳入的函式就被稱作 callback function。我們利用 print function 來去執行 callback function。這個時候控制 callback function 執行的就不是主要程式，而是仰賴著執行 print() 才去執行 callback。這件事情又顯示了 callback function 另一個重要特性：透過函式去決定 callback function 的執行時機。在特定條件和時機時才去「回呼」callback function。</p><div class="language-=js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-=js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">element.addEventListener(&quot;click&quot;, function() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      console.log(&quot;User has clicked on the button!&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">});</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="複製代碼至剪貼簿" title="複製" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>我們在操作 DOM 元素時一定會用到 addEventListener，其實裡面就使用了 callback function！仔細看看 addEventListenr 的第二個參數，和我們上面介紹 callback function 時所講的特性一樣：</p><ol><li>他被當作參數傳入另一函式</li><li>在&#x27;click&#x27;事件被觸發的時候才執行。</li></ol><p><strong> callback function 與非同步 </strong></p><p>callback function 最常使用也能發揮最大益處的地方是在非同步上，也就是要控制多個函式的執行順序時。
先看看以下程式碼：</p><div class="language-=js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-=js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">function firstFn() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  setTimeout(() =&gt; console.log(&#x27;first&#x27;), 3000);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">function secondFn() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  console.log(&#x27;second&#x27;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">//Execute</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">firstFn();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">secondFn();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="複製代碼至剪貼簿" title="複製" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>雖然說我們主要的程式執行的順序是 firstFn() --&gt; secondFn()，可是因為 setTimeout 的緣故，實際列印結果會是 &#x27;second&#x27;, &#x27;first&#x27;。
假設我們今天就是想要讓列印的結果依序為 &#x27;first&#x27;, &#x27;second&#x27; 該怎麼做？ 回呼函式就派上用場拉！</p><div class="language-=js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-=js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">function firstFn(secFn) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  setTimeout(() =&gt; {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    console.log(&#x27;first&#x27;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    secFn();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  }, 3000);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">function secondFn() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  console.log(&#x27;second&#x27;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">//Execute</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">firstFn(secondFn);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="複製代碼至剪貼簿" title="複製" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>這樣寫的結果就是 3 秒之後印出 &#x27;first&#x27; &#x27;second&#x27;，符合了我們的期望。</p><p>以上只是很簡單很簡單的例子，但這概念在向伺服端請求資料的時候就變得相當重要。因為 fetch data 往往需要時間且屬於非同步的行為，而有些函式所做的事情又得仰賴 data，這時候執行順序就變得相當重要，否則會出錯。</p><div class="theme-admonition theme-admonition-info alert alert--info admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span><mdxadmonitiontitle>[callback hell]</mdxadmonitiontitle></div><div class="admonitionContent_S0QG"><p>指的就是在回呼函式裡面包回呼函式又包回呼函式又包回呼函式…相當多層的巢狀 callback，包到天荒地老眼花撩亂，導致維護上相當困難。</p></div></div><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="q4">淺拷貝 vs. 深拷貝<a href="#q4" class="hash-link" aria-label="淺拷貝 vs. 深拷貝的直接連結" title="淺拷貝 vs. 深拷貝的直接連結">​</a></h2><p>淺拷貝(shallow copy) : 原始物件資料與複製物件資料「並非完全獨立」，可能第一層就有指向相同地址的資料，也可能第二層才有指向相同地址的資料。彼此資料內容的改變可能會互相影響。</p><p>深拷貝(deep copy) : 原始物件資料與複製物件資料「完全獨立」，沒有任何一層資料指向相同的地址。彼此資內容料的改變不會互相影響。</p><p>舉例來說，在 JavaScript 內我們經常用 spread operator 來複製物件：</p><div class="language-=js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-=js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">const objA = {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  a: { a: 100 },</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  b: 50,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">};</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">//使用...將objA展開</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">const objC = { ...objA };</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">console.log(objA, objC); //兩個的資料看起來一模一樣</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">objC.a.a = 99;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">objC.b = &#x27;hi&#x27;;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">//猜猜 objA &amp; objC 各自變成什麼模樣？</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="複製代碼至剪貼簿" title="複製" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>答案揭曉！
objA 是 <code>{ a: { a: 99 }, b: 50 }</code>
objC 是 <code>{ a: { a: 99 }, b: &#x27;hi&#x27; }</code></p><p>我們雖然是直接針對 objC 裡面的屬性做更改，但其實我們利用 spread operator 來複製一個新物件是屬於淺拷貝。淺拷貝定義如上，我們其實真正複製的只有第一層。
因此，<code>objC.b = &#x27;hi&#x27;</code> 確確實實只改變了 objC 的 b，objA 的 b 並沒有受到影響。
但是，屬性 a 有兩層啊！兩層以上（包含第二層）的資料和原本的物件是共享記憶體的，因此雖然是直接修改 <code>objC.a.a = 99</code>，卻還是會同時改變了 objA。</p><p>複製物件的方法還有很多，不只有 spread operator，只不過要特別注意 JS 裡面提供的那些複製物件語法，全部都是「淺拷貝」，例如 Object.assign(target, source)等。</p><p>因此，當我們在複製巢狀物件時就要特別小心淺拷貝的問題。</p><p><strong>深拷貝怎麼做？</strong></p><p>想要使用 JS 實作深拷貝比較麻煩一些，因為它本身並未提供深拷貝函式。
其中一個方法：先把資料轉成 JSON，再由 JSON 轉回物件。
我們用上面的例子試試看：</p><div class="language-=js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-=js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">const copy = JSON.parse(JSON.stringify(objA));</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">console.log(copy); //成功複製</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">objA.a.a = &#x27;nono&#x27;;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">objA.b = &#x27;yesyes&#x27;;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">console.log(objA, copy);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">//{ a: { a: &#x27;nono&#x27; }, b: &#x27;yesyes&#x27; }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">//{ a: { a: 100 }, b: 50 }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="複製代碼至剪貼簿" title="複製" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Perfect! 跟我們使用 spread operator 的時候不同，即便是巢狀的資料，也成功複製了一份，而非共享記憶體！
更改原本的物件內容，並沒有連帶影響到複製的物件。</p><p><strong>有沒有更輕鬆的作法啊？</strong></p><p>有的。可以使用 <a href="https://lodash.com/docs/4.17.15#cloneDeep" target="_blank" rel="noopener noreferrer">lodash</a> 裡面提供的 <code>_.cloneDeep</code>。</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="q6">什麼是 event loop?<a href="#q6" class="hash-link" aria-label="什麼是 event loop?的直接連結" title="什麼是 event loop?的直接連結">​</a></h2><p>舉 addEventListener(‘click’, callbackFunc) 為例，當物件被點擊而觸發 click 事件，該 callback function 就會被調用，callback function 會被放進 callback queue 中排隊等待被執行，而當 call stack 有空時，正在排隊等待執行的 callback function 就會被傳入 call stack 中來執行，而這樣的協調機制就稱為「事件循環 (event loop) 」。</p><p>初認識 event loop 的時候，就覺得它好像水上樂園裡滑水道入口的工作人員，他會負責確認滑水道已經沒有人了，才開放下一個遊客溜下去。所以一但發現「喔～現在 call stack 空了呦」，便會引導在 callback queue 乖乖排隊的任務們依序進入 call stack 中執行。</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="7">什麼是 closure 閉包 ?<a href="#7" class="hash-link" aria-label="什麼是 closure 閉包 ?的直接連結" title="什麼是 closure 閉包 ?的直接連結">​</a></h2><p>已經完成執行（已 return）的函式，其內部變數卻依舊存在著並可被存取：</p><div class="language-=js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-=js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">function outerFunction() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  let outerVariable = &#x27;I am from the outer function&#x27;;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  function innerFunction() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    console.log(outerVariable); // innerFunction can access outerVariable</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  return innerFunction;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">const closureFunction = outerFunction();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">closureFunction(); // This will log &quot;I am from the outer function&quot;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="複製代碼至剪貼簿" title="複製" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在以上範例中，innerFunction 可以存取並記憶外部變數 outerVariable，這就是一個「閉包」效果。</p><p><strong>閉包使用情境</strong></p><ul><li>狀態保存</li><li>緩存機制</li><li>模擬私有變數</li></ul><p><strong>閉包缺點</strong></p><p>易造成 memory leak（內存洩露） 的問題，也就是「變數未被使用卻仍存在記憶體內、沒被釋放，進而造成內存資源耗盡」。</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="函式宣告式-vs-函式運算式">函式宣告式 vs. 函式運算式<a href="#函式宣告式-vs-函式運算式" class="hash-link" aria-label="函式宣告式 vs. 函式運算式的直接連結" title="函式宣告式 vs. 函式運算式的直接連結">​</a></h2><p><strong>function declaration 函式宣告式</strong></p><p>使用 <code>function</code> 宣告函式</p><div class="language-=js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-=js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">function fnName () {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="複製代碼至剪貼簿" title="複製" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>function expression 函式運算式</strong></p><p>將函式指定給某變數，並直接使用這個變數名稱來呼叫函式。</p><div class="language-=js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-=js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">//匿名函式</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">const add = function (a, b){</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return a + b;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// 也可以加上名字</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">const print = function greet() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  console.log(&#x27;hi&#x27;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="複製代碼至剪貼簿" title="複製" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>只不過要注意，加上名字的的這個名字只有在自己的函式區塊裡面有效，請看：</p><div class="language-=js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-=js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">const print = function greet() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  console.log(&#x27;hi&#x27;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  console.log(greet); //[Function: greet]</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">};</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">print();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">console.log(greet); //ReferenceError: greet is not defined</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="複製代碼至剪貼簿" title="複製" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>經常配合 ES6 的 arrow function</p><div class="language-=js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-=js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">const add = (a, b) =&gt; {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return a + b;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="複製代碼至剪貼簿" title="複製" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>兩者差異</strong></p><p>hoisting 效果：function declaration 可以在宣告程式碼之前呼叫，不會出問題。
反之， function expression 則會報錯：</p><ul><li>用 var 宣告：<code>TypeError: print is not a function</code></li><li>用 let、const 宣告的話：<code>ReferenceError: Cannot access &#x27;print&#x27; before initialization</code></li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="resources">Resources<a href="#resources" class="hash-link" aria-label="Resources的直接連結" title="Resources的直接連結">​</a></h2><p><a href="https://www.frontendinterviewhandbook.com/javascript-questions/" target="_blank" rel="noopener noreferrer">Frontend Interview handbook</a></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Interview/javascript.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>編輯此頁</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件分頁導覽"><a class="pagination-nav__link pagination-nav__link--prev" href="/Annie-Docusaurus/docs/intro"><div class="pagination-nav__sublabel">上一頁</div><div class="pagination-nav__label">Hello Docusaurus!</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#q1" class="table-of-contents__link toc-highlight">解釋 Event Bubbling</a></li><li><a href="#q2" class="table-of-contents__link toc-highlight">解釋 Event Delegation</a></li><li><a href="#q3" class="table-of-contents__link toc-highlight">什麼是 callback function</a></li><li><a href="#q4" class="table-of-contents__link toc-highlight">淺拷貝 vs. 深拷貝</a></li><li><a href="#q6" class="table-of-contents__link toc-highlight">什麼是 event loop?</a></li><li><a href="#7" class="table-of-contents__link toc-highlight">什麼是 closure 閉包 ?</a></li><li><a href="#函式宣告式-vs-函式運算式" class="table-of-contents__link toc-highlight">函式宣告式 vs. 函式運算式</a></li><li><a href="#resources" class="table-of-contents__link toc-highlight">Resources</a></li></ul></div></div></div></div></main></div></div></div>
<script src="/Annie-Docusaurus/assets/js/runtime~main.989b89fa.js"></script>
<script src="/Annie-Docusaurus/assets/js/main.83db0474.js"></script>
</body>
</html>