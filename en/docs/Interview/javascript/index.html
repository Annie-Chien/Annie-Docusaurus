<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-Interview/javascript">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.0">
<title data-rh="true">JavaScript 問答集 | AnnieAnny</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://annie-chien.github.io/Annie-Docusaurus/en/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://annie-chien.github.io/Annie-Docusaurus/en/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://annie-chien.github.io/Annie-Docusaurus/en/docs/Interview/javascript"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="JavaScript 問答集 | AnnieAnny"><meta data-rh="true" name="description" content="此篇文章主要用來整理與複習常見的 JS 面試問答，因此回答會較精簡，之後再慢慢補上針對特定主題詳細版文章。"><meta data-rh="true" property="og:description" content="此篇文章主要用來整理與複習常見的 JS 面試問答，因此回答會較精簡，之後再慢慢補上針對特定主題詳細版文章。"><link data-rh="true" rel="icon" href="/Annie-Docusaurus/en/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://annie-chien.github.io/Annie-Docusaurus/en/docs/Interview/javascript"><link data-rh="true" rel="alternate" href="https://annie-chien.github.io/Annie-Docusaurus/en/docs/Interview/javascript" hreflang="en"><link data-rh="true" rel="alternate" href="https://annie-chien.github.io/Annie-Docusaurus/docs/Interview/javascript" hreflang="zh-Hant-TW"><link data-rh="true" rel="alternate" href="https://annie-chien.github.io/Annie-Docusaurus/docs/Interview/javascript" hreflang="x-default"><link rel="stylesheet" href="/Annie-Docusaurus/en/assets/css/styles.6c52489b.css">
<link rel="preload" href="/Annie-Docusaurus/en/assets/js/runtime~main.8ca57c4b.js" as="script">
<link rel="preload" href="/Annie-Docusaurus/en/assets/js/main.072952d8.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(e){}return e}()||function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):window.matchMedia("(prefers-color-scheme: light)").matches?e("light"):e("dark")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top navbarHideable_m1mJ"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/Annie-Docusaurus/en/"><b class="navbar__title text--truncate">AnnieAnny&#x27;s</b></a><a class="navbar__item navbar__link" href="/Annie-Docusaurus/en/about">ABOUT</a></div><div class="navbar__items navbar__items--right"><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/Annie-Docusaurus/en/docs/intro">NOTE</a><a href="https://github.com/Annie-Chien" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Github<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><a href="https://medium.com/@annie.chien105" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Medium<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd sidebarWithHideableNavbar_wUlq"><a tabindex="-1" class="sidebarLogo_isFc" href="/Annie-Docusaurus/en/"><b>AnnieAnny&#x27;s</b></a><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/Annie-Docusaurus/en/docs/intro">Hello Docusaurus!</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/Annie-Docusaurus/en/docs/Frontend/d3-part1">Frontend</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/Annie-Docusaurus/en/docs/Interview/javascript">Interview</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/Annie-Docusaurus/en/docs/Interview/javascript">JavaScript 問答集</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Annie-Docusaurus/en/docs/Interview/css">CSS 問答集</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/Annie-Docusaurus/en/docs/JavaScript/Questions">JavaScript</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/Annie-Docusaurus/en/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Interview</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">JavaScript 問答集</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>JavaScript 問答集</h1><p>此篇文章主要用來整理與複習常見的 JS 面試問答，因此回答會較精簡，之後再慢慢補上針對特定主題詳細版文章。</p><div class="theme-admonition theme-admonition-note alert alert--secondary admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span><mdxadmonitiontitle>[目錄]</mdxadmonitiontitle></div><div class="admonitionContent_S0QG"><ul class="contains-task-list containsTaskList_mC6p"><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <a href="#q1">解釋 Event Bubbling</a></li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <a href="#q2">解釋 Event Delegation</a></li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <a href="#q3">什麼是 callback function</a></li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <a href="#q4">淺拷貝 vs. 深拷貝</a></li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <a href="#q5">e.currentTarget vs. e.target</a></li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <a href="#q6">什麼是 event loop</a></li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <a href="#q7">什麼是 closure（閉包）</a></li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <a href="#q8">函式宣告式 vs. 函式運算式</a></li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <a href="#q9">什麼是 Prototype Chain</a></li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <a href="#q10">什麼是 Scope（作用域）</a></li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <a href="#q11">什麼是 AJAX</a></li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <a href="#q12">by sharing vs. by reference</a></li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <a href="#q13">解釋 == 和 === 的差異</a></li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <a href="#q14">什麼是 IIFE</a></li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <a href="#q15">.call vs. .apply</a></li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> <a href="#q16">for...in vs. for...of</a></li></ul></div></div><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="q1">解釋 Event Bubbling<a href="#q1" class="hash-link" aria-label="Direct link to 解釋 Event Bubbling" title="Direct link to 解釋 Event Bubbling">​</a></h2><p>event propagation（事件傳遞）分為三個階段：</p><ol><li>event capturing 捕獲</li><li>event target：找到觸發事件</li><li>event bubbling 冒泡</li></ol><p>冒泡和捕獲最大的差別就在事件傳遞的「順序」。
冒泡的順序是從觸發事件的節點為起點，向上傳遞。而捕獲則是從根節點開始，向下傳遞直到觸發事件的節點。</p><p>addEventListener 其實有第三個參數，用來決定要採用的是冒泡或是捕獲，預設是 false 也就是冒泡。</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="q2">解釋 Event Delegation<a href="#q2" class="hash-link" aria-label="Direct link to 解釋 Event Delegation" title="Direct link to 解釋 Event Delegation">​</a></h2><p>使用事件冒泡（或是捕獲）的特性的一種事件處理模式。假如現在有一個 ul，裡面包了數個 li，而我們在點擊 li 的時候都想要執行某任務。那麼與其在每一個 li 身上綁定 event handler，更有效率的做法就是直接在他們的共同父層 ul 綁定 event handler。</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="q3">什麼是 callback function<a href="#q3" class="hash-link" aria-label="Direct link to 什麼是 callback function" title="Direct link to 什麼是 callback function">​</a></h2><div class="language-=js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-=js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">function print(callback) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    callback();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>像是以上範例，把一個函式當作參數傳入另一函式裡，並在裡面呼叫它。這個被當作參數傳入的函式就被稱作 callback function。我們利用 print function 來去執行 callback function。這個時候控制 callback function 執行的就不是主要程式，而是仰賴著執行 print() 才去執行 callback。這件事情又顯示了 callback function 另一個重要特性：透過函式去決定 callback function 的執行時機。在特定條件和時機時才去「回呼」callback function。</p><div class="language-=js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-=js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">element.addEventListener(&quot;click&quot;, function() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      console.log(&quot;User has clicked on the button!&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">});</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>我們在操作 DOM 元素時一定會用到 addEventListener，其實裡面就使用了 callback function！仔細看看 addEventListenr 的第二個參數，和我們上面介紹 callback function 時所講的特性一樣：</p><ol><li>他被當作參數傳入另一函式</li><li>在&#x27;click&#x27;事件被觸發的時候才執行。</li></ol><p><strong> callback function 與非同步 </strong></p><p>callback function 最常使用也能發揮最大益處的地方是在非同步上，也就是要控制多個函式的執行順序時。
先看看以下程式碼：</p><div class="language-=js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-=js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">function firstFn() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  setTimeout(() =&gt; console.log(&#x27;first&#x27;), 3000);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">function secondFn() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  console.log(&#x27;second&#x27;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">//Execute</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">firstFn();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">secondFn();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>雖然說我們主要的程式執行的順序是 firstFn() --&gt; secondFn()，可是因為 setTimeout 的緣故，實際列印結果會是 &#x27;second&#x27;, &#x27;first&#x27;。
假設我們今天就是想要讓列印的結果依序為 &#x27;first&#x27;, &#x27;second&#x27; 該怎麼做？ 回呼函式就派上用場拉！</p><div class="language-=js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-=js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">function firstFn(secFn) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  setTimeout(() =&gt; {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    console.log(&#x27;first&#x27;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    secFn();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  }, 3000);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">function secondFn() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  console.log(&#x27;second&#x27;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">//Execute</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">firstFn(secondFn);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>這樣寫的結果就是 3 秒之後印出 &#x27;first&#x27; &#x27;second&#x27;，符合了我們的期望。</p><p>以上只是很簡單很簡單的例子，但這概念在向伺服端請求資料的時候就變得相當重要。因為 fetch data 往往需要時間且屬於非同步的行為，而有些函式所做的事情又得仰賴 data，這時候執行順序就變得相當重要，否則會出錯。</p><div class="theme-admonition theme-admonition-info alert alert--info admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span><mdxadmonitiontitle>[callback hell]</mdxadmonitiontitle></div><div class="admonitionContent_S0QG"><p>指的就是在回呼函式裡面包回呼函式又包回呼函式又包回呼函式…相當多層的巢狀 callback，包到天荒地老眼花撩亂，導致維護上相當困難。</p></div></div><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="q4">淺拷貝 vs. 深拷貝<a href="#q4" class="hash-link" aria-label="Direct link to 淺拷貝 vs. 深拷貝" title="Direct link to 淺拷貝 vs. 深拷貝">​</a></h2><p>淺拷貝(shallow copy) : 原始物件資料與複製物件資料「並非完全獨立」，可能第一層就有指向相同地址的資料，也可能第二層才有指向相同地址的資料。彼此資料內容的改變可能會互相影響。</p><p>深拷貝(deep copy) : 原始物件資料與複製物件資料「完全獨立」，沒有任何一層資料指向相同的地址。彼此資內容料的改變不會互相影響。</p><p>舉例來說，在 JavaScript 內我們經常用 spread operator 來複製物件：</p><div class="language-=js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-=js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">const objA = {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  a: { a: 100 },</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  b: 50,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">};</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">//使用...將objA展開</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">const objC = { ...objA };</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">console.log(objA, objC); //兩個的資料看起來一模一樣</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">objC.a.a = 99;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">objC.b = &#x27;hi&#x27;;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">//猜猜 objA &amp; objC 各自變成什麼模樣？</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>答案揭曉！
objA 是 <code>{ a: { a: 99 }, b: 50 }</code>
objC 是 <code>{ a: { a: 99 }, b: &#x27;hi&#x27; }</code></p><p>我們雖然是直接針對 objC 裡面的屬性做更改，但其實我們利用 spread operator 來複製一個新物件是屬於淺拷貝。淺拷貝定義如上，我們其實真正複製的只有第一層。
因此，<code>objC.b = &#x27;hi&#x27;</code> 確確實實只改變了 objC 的 b，objA 的 b 並沒有受到影響。
但是，屬性 a 有兩層啊！兩層以上（包含第二層）的資料和原本的物件是共享記憶體的，因此雖然是直接修改 <code>objC.a.a = 99</code>，卻還是會同時改變了 objA。</p><p>複製物件的方法還有很多，不只有 spread operator，只不過要特別注意 JS 裡面提供的那些複製物件語法，全部都是「淺拷貝」，例如 Object.assign(target, source)等。</p><p>因此，當我們在複製巢狀物件時就要特別小心淺拷貝的問題。</p><p><strong>深拷貝怎麼做？</strong></p><p>想要使用 JS 實作深拷貝比較麻煩一些，因為它本身並未提供深拷貝函式。
其中一個方法：先把資料轉成 JSON，再由 JSON 轉回物件。
我們用上面的例子試試看：</p><div class="language-=js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-=js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">const copy = JSON.parse(JSON.stringify(objA));</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">console.log(copy); //成功複製</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">objA.a.a = &#x27;nono&#x27;;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">objA.b = &#x27;yesyes&#x27;;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">console.log(objA, copy);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">//{ a: { a: &#x27;nono&#x27; }, b: &#x27;yesyes&#x27; }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">//{ a: { a: 100 }, b: 50 }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Perfect! 跟我們使用 spread operator 的時候不同，即便是巢狀的資料，也成功複製了一份，而非共享記憶體！
更改原本的物件內容，並沒有連帶影響到複製的物件。</p><p><strong>有沒有更輕鬆的作法啊？</strong></p><p>有的。可以使用 <a href="https://lodash.com/docs/4.17.15#cloneDeep" target="_blank" rel="noopener noreferrer">lodash</a> 裡面提供的 <code>_.cloneDeep</code>。</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="q5">e.currentTarget vs. e.target<a href="#q5" class="hash-link" aria-label="Direct link to e.currentTarget vs. e.target" title="Direct link to e.currentTarget vs. e.target">​</a></h2><table><thead><tr><th></th><th><code>e.currentTarget</code></th><th><code>e.target</code></th></tr></thead><tbody><tr><td><strong>定義</strong></td><td>綁定事件監聽的元素</td><td>實際觸發事件的元素</td></tr></tbody></table><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="q6">什麼是 event loop<a href="#q6" class="hash-link" aria-label="Direct link to 什麼是 event loop" title="Direct link to 什麼是 event loop">​</a></h2><p>舉 addEventListener(‘click’, callbackFunc) 為例，當物件被點擊而觸發 click 事件，該 callback function 就會被調用，callback function 會被放進 callback queue 中排隊等待被執行，而當 call stack 有空時，正在排隊等待執行的 callback function 就會被傳入 call stack 中來執行，而這樣的協調機制就稱為「事件循環 (event loop) 」。</p><p>初認識 event loop 的時候，就覺得它好像水上樂園裡滑水道入口的工作人員，他會負責確認滑水道已經沒有人了，才開放下一個遊客溜下去。所以一但發現「喔～現在 call stack 空了呦」，便會引導在 callback queue 乖乖排隊的任務們依序進入 call stack 中執行。</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="7">什麼是 closure 閉包<a href="#7" class="hash-link" aria-label="Direct link to 什麼是 closure 閉包" title="Direct link to 什麼是 closure 閉包">​</a></h2><p>已經完成執行（已 return）的函式，其內部變數卻依舊存在著並可被存取：</p><div class="language-=js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-=js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">function outerFunction() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  let outerVariable = &#x27;I am from the outer function&#x27;;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  function innerFunction() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    console.log(outerVariable); // innerFunction can access outerVariable</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  return innerFunction;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">const closureFunction = outerFunction();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">closureFunction(); // This will log &quot;I am from the outer function&quot;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在以上範例中，innerFunction 可以存取並記憶外部變數 outerVariable，這就是一個「閉包」效果。</p><p><strong>閉包使用情境</strong></p><ul><li>狀態保存</li><li>緩存機制</li><li>模擬私有變數</li></ul><p><strong>閉包缺點</strong></p><p>易造成 memory leak（內存洩露） 的問題，也就是變數未被使用卻仍存在記憶體內、沒被釋放，進而造成內存資源耗盡。</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="函式宣告式-vs-函式運算式">函式宣告式 vs. 函式運算式<a href="#函式宣告式-vs-函式運算式" class="hash-link" aria-label="Direct link to 函式宣告式 vs. 函式運算式" title="Direct link to 函式宣告式 vs. 函式運算式">​</a></h2><p><strong>function declaration 函式宣告式</strong></p><p>使用 <code>function</code> 宣告函式</p><div class="language-=js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-=js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">function fnName () {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return ...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>function expression 函式運算式</strong></p><p>將函式指定給某變數，並直接使用這個變數名稱來呼叫函式。</p><div class="language-=js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-=js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">//匿名函式</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">const add = function (a, b){</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return a + b;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// 也可以加上名字</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">const print = function greet() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  console.log(&#x27;hi&#x27;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>只不過要注意，加上名字的的這個名字只有在自己的函式區塊裡面有效，請看：</p><div class="language-=js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-=js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">const print = function greet() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  console.log(&#x27;hi&#x27;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  console.log(greet); //[Function: greet]</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">};</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">print();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">console.log(greet); //ReferenceError: greet is not defined</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>經常配合 ES6 的 arrow function</p><div class="language-=js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-=js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">const add = (a, b) =&gt; {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return a + b;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>宣告式與運算式的差異</strong></p><p>hoisting 效果：function declaration 可以在宣告程式碼之前呼叫，不會出問題。
反之， function expression 則會報錯：</p><ul><li>用 var 宣告：<code>TypeError: print is not a function</code></li><li>用 let、const 宣告的話：<code>ReferenceError: Cannot access &#x27;print&#x27; before initialization</code></li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="9">什麼是 prototype chain<a href="#9" class="hash-link" aria-label="Direct link to 什麼是 prototype chain" title="Direct link to 什麼是 prototype chain">​</a></h2><p>JS 有 OOP（物件導向）的特性，但它並不全然是一個 OOP 語言。
因為一般的 OOP 的語言是建構在 class 之上，而 JS 其實是 prototype-based（以原型為基礎），也就是利用一個叫做 prototype 的物件去建立「繼承」關係。</p><p><strong>什麼是 prototype?</strong></p><p>簡單來說，就是一個作為接下來欲創造的新物件的模型，以此模型為核心基礎，加以改良和調整。
所以說，任何依據此模型所生產出來的物件，都會保有模型原本的特色（繼承關係）。</p><p>當每一個函式被建立的時候，都會有一個隱藏內建的 prototype 屬性。</p><p><strong>什麼是 prototype chain?</strong></p><p>JS 每一個物件都有一個 <code>.__proto__</code> 屬性（除了用 <code>Object.create(null)</code> 所建立的物件），這個屬性會指向建構式的 prototype。當今天在物件內找不到某方法，就會跑到 <code>.__proto__</code> 指向的 prototype 去尋找，如果還是找不到，那就繼續往這個 prototype 的 <code>.__proto__</code> 去找…依此類推，直到 <code>.__proto__</code> 是 null 為止。</p><p>而這個透過<code>.__proto__</code>不斷往上尋找，像是有一條無形的線把物件與物件聯繫起來，就是「原型鏈」。
物件實體會優先存取自己的屬性和方法，找不到的時候才會往原型物件尋找。</p><div class="language-=js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-=js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">function Person (name, birthYear){</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  this.name = name;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  this.birthYear = birthYear;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Person.prototype.greet = function (){</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  console.log(`Hi, I&#x27;m ${this.name}`)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">const justin = new Person(&#x27;Justin&#x27;, 1996); //Person {name: &#x27;Justin&#x27;, birthYear: 1996}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">console.log(justin.hasOwnProperty(&#x27;greet&#x27;)); //false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">console.log(&#x27;greet&#x27; in justin); //true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">justin.greet(); //&quot;Hi, I&#x27;m Justin&quot;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li>建構函式 Person 內有 name 和 birthYear 兩個屬性</li><li>在 建構函式 Person 的 Prototype 放進 greet 函式</li><li>使用 new 創建物件 justin，列印出來後發現物件 justin 本身並未包含 greet 函式，可由 hasOwnProperty() 來驗證。</li><li>operator <code>in</code> 可用來檢查物件本身以及其原型鍊上是否包含該屬性。然而我們發現 <code>&#x27;greet&#x27; in justin</code> 為 true。</li><li>結論：在 justin 物件內找不到 greet 函式，JS 會往它的 <code>.__proto__</code>(指向 Person.Prototype) 尋找，直到找到或是 null 才停止，這正是「原型鍊」的概念。</li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="10">什麼是 Scope（作用域）<a href="#10" class="hash-link" aria-label="Direct link to 什麼是 Scope（作用域）" title="Direct link to 什麼是 Scope（作用域）">​</a></h2><p>Scope（作用域）指變數的生存範圍，一但離開了這個生存範圍，就無法存取。</p><p>JS 內作用域目前有三種：</p><p><strong>1. block scope</strong></p><ul><li>block scope 是在 ES6 才出現，在這之前，最小作用域範圍是 function scope。</li><li>所有在 {} 括號內的東西都稱作 block（區塊）</li><li>在區塊內宣告的變數只能在區塊內取用</li><li>block scope 只適用於用 let 和 const 宣告的變數；若用 var 宣告，則在區塊之外仍可使用。</li></ul><p><strong>2. function scope</strong></p><ul><li>變數只能在函式內部取用</li><li>亦稱作「區域變數(local scope)」</li><li>var 宣告的變數皆是 function scope</li></ul><p><strong>3. global scope</strong></p><ul><li>所有在函式或區塊之外的程式碼(top-level)都屬於全域範疇</li><li>在任何地方都可取用</li><li>如果你沒有使用宣告關鍵字（var, const, let）則會自動變成 global scope</li></ul><div class="theme-admonition theme-admonition-info alert alert--info admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span><mdxadmonitiontitle>[local scope]</mdxadmonitiontitle></div><div class="admonitionContent_S0QG"><p>指的是 function scope &amp; block scope</p></div></div><p><strong>scope chain 範疇鏈</strong></p><p>在自己的作用域內查找變數，若找不到時會往外層繼續尋找，直到全域範疇，尋找變數的這個動作又稱作「Variable lookup（變數查找）」。</p><blockquote><p>只能由內而外，無法由外而內！</p></blockquote><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="q11">什麼是 AJAX<a href="#q11" class="hash-link" aria-label="Direct link to 什麼是 AJAX" title="Direct link to 什麼是 AJAX">​</a></h2><p>AJAX 全名為 Asynchronous JavaScript And XML，透過 AJAX 這項技術，我們可以動態向遠端伺服器請求資料（request data）。讓我們在不需要重整網頁的情況下，就能夠即時地與伺服端交換資料。</p><p>✏️ AJAX 裡面的 X 代表 XML。XML 是一種以前常用來交換資料的格式，現在多用 JSON！不過因為 AJAX 這個詞是以前當 XML 還盛行時所創的，所以才會包含 XML（即便現在已經很少用了）。</p><p><strong>AJAX 的運作方式</strong></p><p>當事件發生時（如載入網頁或是點擊按鈕）...</p><p>瀏覽器會透過 JS 創建一個 XMLHttpRequest 物件，並傳送請求（request）給網路伺服器
伺服器接收到請求後開始進行處理，完成後回應（response）瀏覽器
OK！你或許注意到了以上有個叫做 XMLHttpRequest 的酷東東～
它就是那位幫助我們實行非同步請求的大功臣...嗎？
以前是，但現在不是。</p><p>現在大家都在用 Fetch API，因為它比 XMLHttpRequest(XHR) 更簡單方便。</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="q12">by value vs. by reference<a href="#q12" class="hash-link" aria-label="Direct link to by value vs. by reference" title="Direct link to by value vs. by reference">​</a></h2><p><strong>基本型別的變數傳遞方式是 pass by value （傳值）</strong></p><div class="language-=js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-=js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">let a = &#x27;yes&#x27;;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">let b = a; //複製 a 的值給 b</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">a = &#x27;no&#x27;; // 重新賦予 a 新的值</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">console.log(a, b);//結果是， a: &#x27;no&#x27;, b:&#x27;yes&#x27;。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>改變 a 的值並不會影響到 b，因為變數內容傳遞的方式為傳值，a, b 內容為互相獨立。</p><p><strong>物件則是 pass by reference</strong></p><div class="language-=js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-=js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">let obj = {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  name: &#x27;annie&#x27;,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  age: 24,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">};</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">let obj2 = obj;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">obj2.name = &#x27;jim&#x27;;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">obj2.age = 99;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">console.log(obj, obj2);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">//obj , obj2 都變成 { name: &#x27;jim&#x27;, age: 99 }！</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>我們明明是改變 obj2 的屬性，卻連帶影響到了原本的 obj
因為物件的變數內容傳遞方式為傳址，意思是傳遞的並不是物件的內容，而是記憶體的地址。因此 obj 與 obj2 其實指向的都是同一個記憶體位置，因此修改 obj2 就會影響到 obj。</p><p><strong>pass by sharing</strong></p><p>雖然我們說物件是傳址的，但在某些情況下似乎例外：</p><div class="language-=js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-=js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">let obj1 = {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  name: &#x27;a&#x27;,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  age: 1,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">};</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">let obj2 = obj1;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">console.log(obj1, obj2); //兩個都是{ name: &#x27;a&#x27;, age: 1 }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">obj1 = {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  name: &#x27;b&#x27;,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  age: 100,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">};</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">console.log(obj1, obj2);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">//obj1: { name: &#x27;b&#x27;, age: 100 }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">//obj2: { name: &#x27;a&#x27;, age: 1 }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>咦？奇怪了！剛剛不是說，改變其中一個物件也會影響到另一個物件嗎？那怎麼 obj2 竟然沒有受到影響。
仔細看看，我們在改變 obj1 的變數內容時，是使用物件實字去重新賦值的，因此其實 obj1 已經指向了一個全新的記憶體位置，和 obj2 指向的記憶體已經不同了，所以並不會互相影響。</p><p><strong>重點統整</strong></p><ol><li>基本型別是 pass by value</li><li>物件型別如果是針對變數內容進行更改等操作，是 pass by reference</li><li>物件型別如果是直接重新賦值，則被稱作 pass by value</li></ol><p>因為物件有兩種特殊情況，故有人說 js 屬於 pass by sharing。</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="q13">解釋 == 和 === 的差異<a href="#q13" class="hash-link" aria-label="Direct link to 解釋 == 和 === 的差異" title="Direct link to 解釋 == 和 === 的差異">​</a></h2><table><thead><tr><th><code>==</code></th><th><code>===</code></th></tr></thead><tbody><tr><td>相等運算符</td><td>嚴格相等運算符</td></tr><tr><td>會自動轉換型別</td><td>不會自動轉換型別</td></tr><tr><td>5 == &#x27;5&#x27;(true)</td><td>5 === &#x27;5&#x27;(false)</td></tr></tbody></table><p><strong>Object.is(value1, value2)</strong></p><p><code>Object.is()</code> 與 <code>===</code> 行為類似，差別在於對待 +/-0 和 NaN 的方式：</p><div class="language-=js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-=js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">NaN === NaN //false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">+0 === -0 // true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Object.is(NaN, NaN); //true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Object.is(+0, -0); //false;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="什麼是-iife">什麼是 IIFE<a href="#什麼是-iife" class="hash-link" aria-label="Direct link to 什麼是 IIFE" title="Direct link to 什麼是 IIFE">​</a></h2><p>IIFE 為 Immediately Invoked Function Expressions 的縮寫，是一種能在宣告函式同時執行函式的手段。</p><div class="language-=js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-=js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">(function () {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    // Code to be executed immediately</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">})();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="q15"><code>.call</code> vs. <code>.apply</code><a href="#q15" class="hash-link" aria-label="Direct link to q15" title="Direct link to q15">​</a></h2><p>.call 和 .apply 都是用來觸發函式執行，且第一個參數指定 this 的值。最大的差別在於 .call 是用逗號來分隔要傳入函式參數值，而 .apply 則是用陣列[]。</p><div class="language-=js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-=js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">function multiply(a, b) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  return a * b;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">console.log(add.call(null, 1, 2)); // 2</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">console.log(add.apply(null, [1, 2])); // 2</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="q16"><code>for...in</code> vs. <code>for...of</code><a href="#q16" class="hash-link" aria-label="Direct link to q16" title="Direct link to q16">​</a></h2><table><thead><tr><th>比較</th><th><code>for...in</code></th><th><code>for...of</code></th></tr></thead><tbody><tr><td>對象</td><td>object</td><td>可迭代物件（iterable objects）</td></tr><tr><td>做什麼</td><td>取出 object 的 key</td><td>取出可迭代物件的元素</td></tr><tr><td>注意</td><td>若物件的屬性為 integer properties 時，迭代順序可能不如預期</td><td>不可使用在 object，因為 object 並不是 iterable object</td></tr></tbody></table><div class="theme-admonition theme-admonition-info alert alert--info admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span><mdxadmonitiontitle>[可迭代物件]</mdxadmonitiontitle></div><div class="admonitionContent_S0QG"><p>可迭代物件的特色是有個 <!-- -->[Symbol.iterator]<!-- --> 方法，此方法會回傳「迭代器（iterator）」，而迭代器內提供 next() 函式，可用來依序迭代可迭代物件內的元素。</p></div></div><p>參考之前寫的文章 🔗<a href="https://medium.com/@annie.chien105/js%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E8%AA%8D%E8%AD%98-for-in-%E8%88%87%E4%BB%96%E7%9A%84%E5%85%84%E5%BC%9F-for-of-6e71d61709dd" target="_blank" rel="noopener noreferrer">【JS 學習筆記】認識 for…in 與他的兄弟 for…of</a></p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="resources">Resources<a href="#resources" class="hash-link" aria-label="Direct link to Resources" title="Direct link to Resources">​</a></h2><p><a href="https://www.frontendinterviewhandbook.com/javascript-questions/" target="_blank" rel="noopener noreferrer">Frontend Interview handbook</a></p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/Annie-Docusaurus/en/docs/Frontend/svg"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">認識 SVG：在網頁上製圖</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/Annie-Docusaurus/en/docs/Interview/css"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">CSS 問答集</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#q1" class="table-of-contents__link toc-highlight">解釋 Event Bubbling</a></li><li><a href="#q2" class="table-of-contents__link toc-highlight">解釋 Event Delegation</a></li><li><a href="#q3" class="table-of-contents__link toc-highlight">什麼是 callback function</a></li><li><a href="#q4" class="table-of-contents__link toc-highlight">淺拷貝 vs. 深拷貝</a></li><li><a href="#q5" class="table-of-contents__link toc-highlight">e.currentTarget vs. e.target</a></li><li><a href="#q6" class="table-of-contents__link toc-highlight">什麼是 event loop</a></li><li><a href="#7" class="table-of-contents__link toc-highlight">什麼是 closure 閉包</a></li><li><a href="#函式宣告式-vs-函式運算式" class="table-of-contents__link toc-highlight">函式宣告式 vs. 函式運算式</a></li><li><a href="#9" class="table-of-contents__link toc-highlight">什麼是 prototype chain</a></li><li><a href="#10" class="table-of-contents__link toc-highlight">什麼是 Scope（作用域）</a></li><li><a href="#q11" class="table-of-contents__link toc-highlight">什麼是 AJAX</a></li><li><a href="#q12" class="table-of-contents__link toc-highlight">by value vs. by reference</a></li><li><a href="#q13" class="table-of-contents__link toc-highlight">解釋 == 和 === 的差異</a></li><li><a href="#什麼是-iife" class="table-of-contents__link toc-highlight">什麼是 IIFE</a></li><li><a href="#q15" class="table-of-contents__link toc-highlight"><code>.call</code> vs. <code>.apply</code></a></li><li><a href="#q16" class="table-of-contents__link toc-highlight"><code>for...in</code> vs. <code>for...of</code></a></li><li><a href="#resources" class="table-of-contents__link toc-highlight">Resources</a></li></ul></div></div></div></div></main></div></div></div>
<script src="/Annie-Docusaurus/en/assets/js/runtime~main.8ca57c4b.js"></script>
<script src="/Annie-Docusaurus/en/assets/js/main.072952d8.js"></script>
</body>
</html>